package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
)

type Topo struct {
	Hosts    []string    `json:"hosts"`
	Switches []string    `json:"switches"`
	Links    [][2]string `json:"links"`
}

func main() {
	// CLI flags
	useCLI := flag.Bool("cli", false, "enter Mininet CLI instead of running pingall")
	remote := flag.String("remote", "", "remote target to run on, e.g. mininet@192.168.64.5 (REQUIRED)")
	remotePath := flag.String("remote-path", "/tmp/topo_from_json.py", "remote path for the generated Python file")
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr,
			"Usage: %s --remote=user@ip [--cli] [--remote-path=/tmp/xxx.py] <topo.json>\n",
			filepath.Base(os.Args[0]))
		flag.PrintDefaults()
	}
	flag.Parse()

	if flag.NArg() < 1 {
		flag.Usage()
		os.Exit(2)
	}
	if *remote == "" {
		fmt.Fprintln(os.Stderr, "ERROR: --remote is required (e.g., --remote=mininet@192.168.64.5)")
		os.Exit(2)
	}
	inPath := flag.Arg(0)

	// 1) Read topology JSON file
	data, err := os.ReadFile(inPath)
	if err != nil {
		die("read topo file", err)
	}
	var topo Topo
	if err := json.Unmarshal(data, &topo); err != nil {
		die("parse JSON", err)
	}

	// 2) Generate a temporary Python script for mn --custom
	py := buildMininetPython(topo)
	tmpFile, err := os.CreateTemp("", "topo_from_json_*.py")
	if err != nil {
		die("create temp python", err)
	}
	defer os.Remove(tmpFile.Name())
	if _, err := tmpFile.WriteString(py); err != nil {
		die("write temp python", err)
	}
	_ = tmpFile.Close()

	// 3) Remote run only (no local mode)
	if err := runRemote(tmpFile.Name(), *remote, *remotePath, *useCLI); err != nil {
		die("run remote mn", err)
	}
}

// runRemote copies the generated Python file via scp,
// then launches Mininet on the remote VM via ssh.
func runRemote(localPy, remote, remotePath string, useCLI bool) error {
	// 3.1) Upload Python file with scp
	scp := exec.Command("scp", localPy, fmt.Sprintf("%s:%s", remote, remotePath))
	scp.Stdin, scp.Stdout, scp.Stderr = os.Stdin, os.Stdout, os.Stderr
	fmt.Printf("-> Uploading via scp: %v\n", scp.Args)
	if err := scp.Run(); err != nil {
		return fmt.Errorf("scp failed: %w", err)
	}

	// Schedule cleanup of the remote Python file after execution
	defer func() {
		rm := exec.Command("ssh", remote, "rm", "-f", remotePath)
		rm.Stdin, rm.Stdout, rm.Stderr = os.Stdin, os.Stdout, os.Stderr
		fmt.Printf("-> Cleaning up remote file: %v\n", rm.Args)
		_ = rm.Run() // best-effort cleanup (ignore errors)
	}()

	// 3.2) ssh into remote VM and run Mininet
	var sshArgs []string
	if useCLI {
		// Pure interactive mode (manual input required, user must type "exit")
		sshArgs = []string{"-tt",
			remote, "sudo", "mn",
			"--custom", remotePath,
			"--topo", "fromjson",
		}
	} else {
		// Built-in test mode (runs pingall automatically, then exits)
		sshArgs = []string{"-tt",
			remote, "sudo", "mn",
			"--custom", remotePath,
			"--topo", "fromjson",
			"--test", "pingall",
		}
	}

	ssh := exec.Command("ssh", sshArgs...)
	ssh.Stdin, ssh.Stdout, ssh.Stderr = os.Stdin, os.Stdout, os.Stderr
	fmt.Printf("-> Running (remote via ssh): %v\n", ssh.Args)
	return ssh.Run()
}

// Print error and exit program
func die(what string, err error) {
	fmt.Fprintf(os.Stderr, "ERROR: %s: %v\n", what, err)
	os.Exit(1)
}

// Build a Python script for Mininet that generates hosts, switches, and links
func buildMininetPython(t Topo) string {
	return fmt.Sprintf(`# Auto-generated by Go
from mininet.topo import Topo

class FromJSON(Topo):
    def build(self):
%s
%s
%s

topos = { 'fromjson': ( lambda: FromJSON() ) }
`, pyAddHosts(t.Hosts), pyAddSwitches(t.Switches), pyAddLinks(t.Links))
}

// Generate Python code for adding hosts
func pyAddHosts(hosts []string) string {
	s := ""
	for _, h := range hosts {
		s += fmt.Sprintf("        %s = self.addHost('%s')\n", h, h)
	}
	return s
}

// Generate Python code for adding switches
func pyAddSwitches(sw []string) string {
	s := ""
	for _, x := range sw {
		s += fmt.Sprintf("        %s = self.addSwitch('%s')\n", x, x)
	}
	return s
}

// Generate Python code for adding links
func pyAddLinks(links [][2]string) string {
	s := ""
	for _, lk := range links {
		a, b := lk[0], lk[1]
		s += fmt.Sprintf("        self.addLink(%s, %s)\n", a, b)
	}
	return s
}
